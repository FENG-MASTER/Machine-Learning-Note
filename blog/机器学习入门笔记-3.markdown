# 前言 #

这次笔记是针对教程中的Octave教学部分,就是Octave的一个简单入门,教你一些基本的语法使用

# Octave #

Octave是一个开源的编程语言,和Matlab很相似,一般就是用于科学计算啦,和之前我一直接触的专门用于开发软件的语言还是有一定差异的,下载网址我顺带贴在下面了

下载网址:http://www.gnu.org/software/octave/

顺带一提,他是解析型语言.

## 安装 ##

略,装个软件难道还要说明书?

## 基础操作 ##

### 实数简单运算 ###

1. 3+2
2. 1-2
3. 3*3
4. 1/3
5. 3^2(3的2次幂)

### 逻辑运算 ###

1. 相等 1==2  结果0(false)[说明一下,虽然显示0,不意味着这个是整数,在Octave中有逻辑型的变量类型]
2. 不相等 1~=2  结果1(true)
3. 不相等 1!=2  结果1(true)
4. 逻辑与 1&&0  结果0
5. 算数与 1&0   结果0**[区别和其他语言类似,算数与有短路的特征]**
6. 逻辑或 1||0  结果1
7. 算数或 1|0   结果1**[区别同算数与,依旧有短路的特征]**
8. 异或 xor(1,0) 结果1





### 变量声明 ###

1. a = 1  %即声明了一个变量,值为1
2. b='hi' %即声明一个变量,值为字符串hi


### 屏幕输出 ###

1. a  &nbsp;&nbsp;&nbsp; %这样就可以简单打印出a的内容
2. disp(a)  %也是简单的打印a的内容,但使用disp可以有参数,自己查
3. format short  %修改默认输出格式为short型

### 矩阵 ###

1. A=[1,2;3,4;5,6]

	定义了一个A矩阵,内容为

		A =

  		 1   2
  		 3   4
	  	 5   6

2. V=[1,2,3]

	定义了一个V 行向量,内容为

		V =

  		 1   2   3

3. V=[1;2;3]

	定义了一个V 列向量,内容为

		V =

 		  1
 		  2
  		  3

4. V=1:0.2:2

	定义了一个V 行向量,内容为

		V =

   		 1.0000    1.2000    1.4000    1.6000    1.8000    2.0000

 一种快捷方便的定义特殊行向量的方法,第一个数表示起始值,中间一个数表示步长,最后一个表示最大值,即定义了一个从1开始,每次加0.2,加到大于等于2为止的行向量

5. A = ones(3,4)

	定义了一个A矩阵,内容为

		A =

  		 1   1   1   1
  		 1   1   1   1
  		 1   1   1   1

即定义一个全为1的矩阵

6. A= zeros(3,4)

	类似ones,但内容全为0

7. A=rand(2,3)

	生成一个随机数内容的矩阵,随机范围0-1

		A =

  		 0.97381   0.28127   0.67071
 		 0.44791   0.92470   0.73870
8. A=randn(1,3)

	生成一个高斯分布的随机内容的矩阵

		A =

		  -1.45181  -0.63449   0.92469
9. hist(A) 显示A的直方图

10. eye(3) 

	生成一个维度为3的单位矩阵

### 其他 ###

1. 注释 %后写注释即可
2. 去掉屏幕输出 语句后加;分号即可
	
		如 a=3;  %这样写的话,你的语句不会有任何输出

3. size(A)  求A的大小

如果A=[1,2;3,4;5,6],size(A)结果是  3  2  (矩阵形式)

4. size(A,1) 结果为3,表示size的第一个值
5. size(A,2) 结果为2,表示size的第二个值
6. length(A) 求A的最大维度大小

## 数据装载和保存 ##

### 基础 ###

1. psd 查看当前所在目录(即工作目录)
2. ls 列出当前目录文件
3. cd 打开目录

### 装载 ###

load 文件名1 或者 load('文件名1')  

这样会加载当前目录下的文件名1的数据文件到octave中,并且变量名为文件名,其他进阶用法自己用help查

### 保存 ###

save 文件名1 变量名

这样会把变量名对应的变量存储到文件名1中

## 数据操作 ##

首先我们令A=[1,2;3,4;5,6]

	A =

  	 1   2
  	 3   4
 	 5   6

1. A(2,1)  表示A中的第2行第1列 即 3
2. A(2,:)  表示A中第2行的所有内容  :冒号表示行/列的所有内容
3. A(:,2)  表示A中第2列的所有内容
4. A([1,3],:) 表示A中1行和3行的所有内容
5. A(2,:)=[4,3] 表示对A中第2行的所有内容进行赋值 (对,你没有看错,就是赋值)
6. A=[A,[4;5;7]] 表示在A的右部追加一列[4,,5,7]
7. A(:) 表示把A的所有内容变成一个列向量

		ans =

  		 1
  		 3
   		 5
   		 2
  		 4
   		 6

8. C=[A B] 即定义一个C,C的内容为A和B组合起来,**一个左边 一个右边**(当然,你需要保证A B的行数相同)
9. C=[A;B] 即定义一个C,C的内容为A和B组合起来,**一个上,一个下**

## 数据运算 ##

A=[1,2;3,4;5,6]

	A =

   	1   2
   	3   4
   	5   6

B=[11,12;13,14;15,16]

	B =

 	  11   12
  	  13   14
   	  15   16


C=[1,1;2,2]

	C =

  	 1   1
  	 2   2



1. A*C 矩阵相乘

		ans =

  		  5    5
 		  11   11
  		  17   17
2. A.*B 矩阵按照元素为单位相乘

		ans =

	   11   24
 	   39   56
 	   75   96

	即 

		ans =

	  1*11   2*12
 	  3*13   4*14
 	  5*15   6*16

3. A .^2 矩阵按照元素为单位算二次幂

		ans =

   		 1    4
   		 9   16
  		 25   36

即 计算出每个元素的二次幂

4. exp(A) 计算e为底,每个元素次方

		ans =

  		  2.7183     7.3891
   		 20.0855    54.5982
   		148.4132   403.4288



5. A' 求A的转置矩阵. 即AT
6. A<3 求矩阵A中小于3的有哪些,结果是一个逻辑矩阵(1表示符合)

		ans =

 		 1  1
 		 0  0
 		 0  0


7. [r,c]=find(A<4) 找到A中小于4的元素,位置存储在r和c中

		r =

  		 1
  		 2
  		 1

		c =

 		 1
  		 1
  		 2

	即A(1,1),A(2,1),A(1,2)这三个元素小于4

8. sum求和函数,用在矩阵和向量上的时候,功能表现不太一样,用在矩阵上的话,会计算每一列之和,用在向量会直接计算总和

9. floor 向下取整
10. ceil 向上取整
11. sum(A,1) 按照A的第1纬度算出各个第1纬度元素之和
12. max(A,[],1) 按照A的第1纬度算出各个第1纬度元素最大值
13. pinv(A) 求A的逆矩阵



## 绘制数据 ##

1.  绘制单个函数

		t=[0:0.01:1]

	    y1=sin(2*pi*2*t)

	然后执行

		plot(t,y1)

	就绘制出了sin函数

	![](file:///E:/opensource/ml/Machine-Learning-Note/blog/img/8.png)


2. 绘制两个函数

		t=[0:0.01:1]

	    y1=sin(2*pi*2*t)

            y2=cos(2*pi*2*t)

	然后执行

		plot(t,y1)

	绘制出一个sin图像

	执行

		hold on

		plot(t,y2,'r')

	就绘制出了cos函数

	xlabel('time')表示给x轴time标签

	ylabel('value')表示给y轴value标签

	legend('sin','cos')表示给曲线分别命名

	title('haha')表示给图表命名

	print -dpng 'mypng.png'保存图片

	![](file:///E:/opensource/ml/Machine-Learning-Note/blog/img/9.png)

3. 在多个窗口绘制不同函数

	你只需要在绘制前调用

		figure(X)  X表示你这个窗口是第几个

4. 可视化矩阵

	imagesc(A)可视化矩阵,自己试试就知道了

	imagesc(A),colorbar,colormap gray 这个是灰度图显示



## 控制语句 ##

### if语句 ###

1.简单if语句

 	if i==2,
  		disp('hi');
	end;

>当然,你可以直接写成一行


2.if else语句

 	if i==0,
		disp('0');
	eles if i==1,
		disp('1');
	else
   		disp('dn');
	end;



### for语句 ###

	 A=(1:20)'     %初始化A,1-20的序列
	 
	for i=1:8,
 		 A(i)=0;
	 end;


  结果

	A =

          0
          0
          0
    	  0
          0
          0
          0
          0
          9
          10
          11
          12
          13
          14
          15
          16
          17
          18
          19
          20

可以看到,我们把前8个元素变成了0

### while语句 ###

	V=(1:20)'  %初始化V为1-20的行向量

	i=1;  %初始化i,如果不初始化会报错,因为V(i)这个表达要求i为整数型

	while i<12,
   		 V(i)=999;
   	 	 i=i+1;
	end;


结果

	V =

		999
		999
		999
		999
		999
		999
		999
		999
		999
		999
		999
		12
		13
		14
		15
		16
		17
		18
		19
		20

当然,我们还可以使用break和continue,用法不说



## 函数 ##

Octave中定义函数的方法比较非主流,总的来说就是把函数定义为一个文件(后缀.m),然后Octave就识别啦,我们来看下具体操作

### 如何定义一个函数文件 ###

新建一个文本文件,另存为的时候命名为 函数名.m 就可以了

一个简单的函数文件内容如下

	function [y,z]= SquareAndCubeThisNumber(x)

	y=x^2;
	z=x^3;

SquareAndCubeThisNumber是这个函数的**函数名**,所以请确保这个文件保存的时候命名为SquareAndCubeThisNumber.m

[y,z] 表示这个函数返回值是一个矩阵,(这就意味着你可以返回多个值啦,这里返回了两个值),并且返回值为y和z

后面剩下的就是函数体,我们给y和z分别赋值了,这样当y和z作为返回值的时候就是我们计算和的那个值啦


### 识别函数 ###

默认情况下Octave只识别当前工作路径下的所有.m文件为函数

PS:pwd可以查看当前工作路径

或者

addpath('路径');    这样Octave在找函数的时候就会找这个路径(类比java的环境变量)


### 调用 ###

....直接调用就好了
